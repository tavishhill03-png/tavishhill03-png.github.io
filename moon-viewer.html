<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Moon Viewer with Tilted Sunlight</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
      width: 100%;
    }

    #moon-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }

    /* Vertical phase slider on the left */
    #phase-slider-wrapper {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* wrapper doesn't interfere with mouse */
    }

    #phase-slider {
      pointer-events: auto; /* but the slider itself can be interacted with */
      width: 150px;         /* used as "length" since we rotate it */
      transform: rotate(-90deg);
      /* Basic styling; you can customize more as needed */
      -webkit-appearance: none;
      appearance: none;
      background: #333;
      height: 6px;
      border-radius: 3px;
      outline: none;
    }

    #phase-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ccc;
      cursor: pointer;
    }

    #phase-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ccc;
      cursor: pointer;
      border: none;
    }
  </style>
</head>
<body>
  <div id="moon-container">
    <div id="phase-slider-wrapper">
      <input
        id="phase-slider"
        type="range"
        min="0"
        max="1"
        step="0.001"
        value="0.25"
      />
    </div>
  </div>

  <!-- Three.js and helpers -->
  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.159.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.159.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let moon = null;
    let dirLight, ambientLight;
    const sunDir = new THREE.Vector3();

    // Elevation angle for sunlight: negative = from below equator
    const SUN_ELEV_DEG = -20;
    const SUN_ELEV_RAD = THREE.MathUtils.degToRad(SUN_ELEV_DEG);

    const container = document.getElementById('moon-container');
    const phaseSlider = document.getElementById('phase-slider');

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      const width = container.clientWidth;
      const height = container.clientHeight;

      camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
      camera.position.set(0, 0, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setClearColor(0x000000, 1);
      container.appendChild(renderer.domElement);

      // Lights: low ambient + directional as Sun
      ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
      scene.add(ambientLight);

      dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
      dirLight.castShadow = false;
      scene.add(dirLight);

      dirLight.target.position.set(0, 0, 0);
      scene.add(dirLight.target);

      // Initial lighting from slider's default value
      updateLightingFromPhase(parseFloat(phaseSlider.value));

      // OrbitControls (no auto-rotation; mouse wheel zoom enabled)
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = false;
      controls.autoRotate = false;
      controls.enableZoom = true;
      controls.minDistance = 2.0;
      controls.maxDistance = 15.0;

      // Slightly limit vertical rotation so "below" has meaning visually if you want
      // controls.minPolarAngle = 0.2;
      // controls.maxPolarAngle = Math.PI - 0.2;

      // Load high-res Moon model
      const loader = new THREE.GLTFLoader();
      loader.load(
        'the_moon.glb',          // make sure this path matches where you host the glb
        (gltf) => {
          moon = gltf.scene;
          scene.add(moon);

          // Optionally normalize scale so radius is ~1–2 units
          const box = new THREE.Box3().setFromObject(moon);
          const size = new THREE.Vector3();
          box.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          const desiredRadius = 2.0; // tweak as you like
          const scaleFactor = (desiredRadius * 2) / maxDim;
          moon.scale.setScalar(scaleFactor);

          // Center the model
          const center = new THREE.Vector3();
          box.getCenter(center);
          moon.position.sub(center.multiplyScalar(scaleFactor));

          // Ensure lighting is updated now that the Moon is present
          updateLightingFromPhase(parseFloat(phaseSlider.value));
        },
        undefined,
        (error) => {
          console.error('Error loading the_moon.glb:', error);
        }
      );

      // Slider interaction
      phaseSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        updateLightingFromPhase(val);
      });

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      const width = container.clientWidth;
      const height = container.clientHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
    }

    // phaseValue: 0 → 1
    // We rotate the Sun around the Moon in azimuth, with a fixed elevation below horizontal
    function updateLightingFromPhase(phaseValue) {
      const phaseRad = phaseValue * Math.PI * 2; // 0 → 2π

      // direction from Sun toward Moon in Moon's coordinate frame
      sunDir.set(
        Math.cos(SUN_ELEV_RAD) * Math.cos(phaseRad), // x
        Math.sin(SUN_ELEV_RAD),                      // y (negative = from "below")
        Math.cos(SUN_ELEV_RAD) * Math.sin(phaseRad)  // z
      ).normalize();

      // Place the directional light far away along this direction
      const lightDistance = 50; // arbitrary; large enough to approximate parallel rays
      dirLight.position.copy(sunDir).multiplyScalar(lightDistance);

      // Always point light at the Moon's center (0,0,0 in this setup)
      dirLight.target.position.set(0, 0, 0);
      dirLight.target.updateMatrixWorld();
    }

    function animate() {
      requestAnimationFrame(animate);

      if (controls) {
        controls.update();
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
