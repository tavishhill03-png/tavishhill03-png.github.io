<script type="module">
  import * as THREE from "./three/three.module.js";

  const container = document.getElementById("container");

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 3);

  const ambient = new THREE.AmbientLight(0xffffff, 0.05);
  scene.add(ambient);

  const sunLight = new THREE.DirectionalLight(0xffffff, 1.4);
  sunLight.position.set(5, 0, 0);
  scene.add(sunLight);

  const radius = 1;
  const moon = new THREE.Mesh(
    new THREE.SphereGeometry(radius, 64, 64),
    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0 })
  );
  scene.add(moon);

  // === improved marker ===
  const marker = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 32, 32),
    new THREE.MeshStandardMaterial({
      color: 0x00ff00,    // bright green
      emissive: 0x00ff00, // glows even in dark
      emissiveIntensity: 1.0
    })
  );

  // place on equator, slightly toward camera
  marker.position.set(0, 0, radius * 1.05);
  moon.add(marker);
  // === end marker ===

  let dragging = false;
  let lastX = 0, lastY = 0;

  renderer.domElement.addEventListener("pointerdown", e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  window.addEventListener("pointerup", () => dragging = false);
  window.addEventListener("pointermove", e => {
    if (!dragging) return;
    moon.rotation.y += (e.clientX - lastX) * 0.01;
    moon.rotation.x += (e.clientY - lastY) * 0.01;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  function animate() {
    requestAnimationFrame(animate);
    moon.rotation.y += 0.015;
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
